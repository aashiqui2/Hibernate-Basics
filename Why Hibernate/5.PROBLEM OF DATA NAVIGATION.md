# Problem of data navigation
   Java uses. operator to navigate  but RDBMS uses JOINS to navigate



# 🔹 Problem of Data Navigation

### In **Java / OOP**

* Objects are connected via **references** (direct pointers).
* Navigating data = **traversing object references**.
* Example:

```java
class Owner {
    Pet pet;   // has-a relationship
}

Owner owner = new Owner();
Pet pet = owner.getPet();  // direct navigation via reference
```

👉 Super easy: you just call a method like `owner.getPet()`.

---

### In **RDBMS (SQL)**

* No object references.
* Associations are expressed using **foreign keys**.
* Navigating data = **writing queries with joins**.

Example:

```sql
SELECT * 
FROM owner o 
JOIN pet p ON o.pet_id = p.id
WHERE o.id = 101;
```

👉 Here, you can’t just “call `o.getPet()`”. You have to **manually write JOINs** to traverse relationships.

---

### 🔹 The Mismatch

* **OOP** → Direct navigation through object references (simple, natural).
* **RDBMS** → Must perform queries with joins, which is more verbose and **shifts navigation logic into SQL** instead of object relationships.

---

### 🔹 How Hibernate Solves This

Hibernate bridges this by **mapping associations** (One-to-One, One-to-Many, Many-to-Many).

Example (Entity Classes):

```java
@Entity
class Owner {
    @Id
    private int id;

    @OneToOne(mappedBy = "owner", cascade = CascadeType.ALL)
    private Pet pet;
}

@Entity
class Pet {
    @Id
    private int id;

    @OneToOne
    private Owner owner;
}
```

Now, navigation is as natural as in OOP:

```java
Owner owner = session.get(Owner.class, 101);
Pet pet = owner.getPet();   // Hibernate automatically loads the Pet
```

* Hibernate converts the **object navigation** into the **required SQL joins** behind the scenes.
* It even supports **lazy loading** → the related data (Pet) is fetched only when accessed, not immediately.

---

### 🔹 Summary

* **Java:** Navigation is object references (`owner.getPet()`).
* **RDBMS:** Navigation is foreign keys + joins (`SELECT ... JOIN ...`).
* **Problem:** Two completely different navigation models.
* **Hibernate’s Fix:** Maps associations so developers can navigate via objects, while Hibernate translates it into efficient SQL automatically.

