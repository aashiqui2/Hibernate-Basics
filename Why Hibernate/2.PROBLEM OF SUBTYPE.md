# Problem of subtype
  OOPS support inheritance but inheritance is not defined explicitly in any standardized RDBMS

---

## üîπ Problem of Subtype (Inheritance Problem)

### In OOP (Java, C#, etc.)

We can **model inheritance** naturally:

```java
public class Person {
    private int id;
    private String name;
}

public class Employee extends Person {
    private double salary;
}

public class Customer extends Person {
    private String loyaltyCard;
}
```

* `Employee` and `Customer` inherit `id` and `name` from `Person`.
* OOP languages understand inheritance natively.

---

### In RDBMS (Relational Databases)

‚ö†Ô∏è **SQL tables don‚Äôt have inheritance.**

* Tables are flat.
* We must use columns and relations to simulate inheritance.
* No `extends` or `superclass` concept in SQL.

So how do we represent `Person`, `Employee`, and `Customer` in the DB?

---

## üîπ Common Mapping Strategies

ORM tools like Hibernate define strategies to handle this mismatch.

### 1. **Single Table Inheritance (Table per Hierarchy)**

üëâ All classes (`Person`, `Employee`, `Customer`) in **one table** with a `discriminator` column.

```sql
CREATE TABLE person (
    id INT PRIMARY KEY,
    name VARCHAR(50),
    salary DECIMAL(10,2),      -- used only for Employee
    loyalty_card VARCHAR(20),  -- used only for Customer
    dtype VARCHAR(20)          -- "EMPLOYEE" or "CUSTOMER"
);
```

‚úÖ Pros: Simple, fast queries.
‚ùå Cons: Sparse table (nulls in irrelevant columns).

---

### 2. **Table per Subclass (Joined Inheritance)**

üëâ One table for superclass + one table for each subclass.
They are linked by foreign key.

```sql
CREATE TABLE person (
    id INT PRIMARY KEY,
    name VARCHAR(50)
);

CREATE TABLE employee (
    id INT PRIMARY KEY,
    salary DECIMAL(10,2),
    FOREIGN KEY (id) REFERENCES person(id)
);

CREATE TABLE customer (
    id INT PRIMARY KEY,
    loyalty_card VARCHAR(20),
    FOREIGN KEY (id) REFERENCES person(id)
);
```

‚úÖ Pros: Normalized design, no nulls.
‚ùå Cons: Requires joins (slower queries).

---

### 3. **Table per Concrete Class**

üëâ Each subclass has its own table with all fields (including inherited ones).

```sql
CREATE TABLE employee (
    id INT PRIMARY KEY,
    name VARCHAR(50),
    salary DECIMAL(10,2)
);

CREATE TABLE customer (
    id INT PRIMARY KEY,
    name VARCHAR(50),
    loyalty_card VARCHAR(20)
);
```

‚úÖ Pros: No joins, no nulls.
‚ùå Cons: Data duplication (Person‚Äôs fields repeated in each subclass).

---

## üîπ Why Hibernate Helps

Manually implementing this in JDBC means:

* Writing different SQL for each inheritance strategy.
* Writing lots of `JOIN` queries.
* Handling discriminator columns yourself.

üëâ **Hibernate automates all of this.**
Just annotate your class hierarchy:

```java
@Entity
@Inheritance(strategy = InheritanceType.JOINED)
public class Person { ... }

@Entity
public class Employee extends Person { ... }

@Entity
public class Customer extends Person { ... }
```

Hibernate takes care of table creation, discriminator columns, joins, etc.

---

## üîπ Summary

* **OOP supports inheritance**, but **RDBMS does not**.
* This mismatch is called the **Subtype / Inheritance Problem**.
* Hibernate solves it using strategies:

  1. Single Table (Table per Hierarchy)
  2. Joined (Table per Subclass)
  3. Table per Concrete Class

That‚Äôs why ORM is so useful ‚Äî it **bridges the gap between inheritance in OOP and flat relational DBs**.


