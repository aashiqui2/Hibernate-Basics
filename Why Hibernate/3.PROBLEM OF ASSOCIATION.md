# Problem of asscociation:
  Oop represent associations (has a relationship) using object references but in RDBMS association is by a foreign key column.

  
## üîπ Problem of Association

### In **OOP** (Java, C#, etc.)

* Associations are represented using **object references**.
* Example:

```java
public class Student {
    private int id;
    private String name;
    private Course course;   // association (Student has a Course)
}

public class Course {
    private int id;
    private String title;
}
```

Here, a `Student` object holds a reference to a `Course` object.

* It‚Äôs **natural** to say: `student.getCourse().getTitle()`

---

### In **RDBMS**

* Relational databases don‚Äôt have ‚Äúobject references‚Äù.
* Instead, associations are represented using **foreign keys**.

Example tables:

```sql
CREATE TABLE course (
    id INT PRIMARY KEY,
    title VARCHAR(50)
);

CREATE TABLE student (
    id INT PRIMARY KEY,
    name VARCHAR(50),
    course_id INT,                     -- foreign key column
    FOREIGN KEY (course_id) REFERENCES course(id)
);
```

Here, `student.course_id` refers to `course.id`.

* To fetch the course title of a student, we must **JOIN**:

```sql
SELECT s.name, c.title
FROM student s
JOIN course c ON s.course_id = c.id;
```

---

## üîπ The Gap (Mismatch)

* In **OOP**: Association = reference (direct navigation `student.getCourse()`).
* In **RDBMS**: Association = foreign key (requires `JOIN`).

This mismatch is what we call the **Problem of Association**.

---

## üîπ How Hibernate Helps

Hibernate automatically maps object references ‚Üî foreign keys.

* You write **object-oriented code**, Hibernate generates the SQL.

Example:

```java
@Entity
public class Student {
    @Id
    private int id;
    private String name;

    @ManyToOne   // many students can enroll in one course
    private Course course;
}

@Entity
public class Course {
    @Id
    private int id;
    private String title;
}
```

Hibernate takes care of:

* Creating the foreign key (`student.course_id`).
* Running the proper JOINs when you call `student.getCourse()`.

So you don‚Äôt manually write:

```sql
SELECT * FROM student JOIN course ...
```

Instead you just do:

```java
student.getCourse().getTitle();
```

---

‚úÖ **Summary**

* OOP: association via **references**.
* RDBMS: association via **foreign keys**.
* Hibernate (ORM) **bridges this gap**, letting you use OOP style while it handles SQL joins under the hood.

