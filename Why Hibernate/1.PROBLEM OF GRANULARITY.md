# Problem of Object-Relational Impedance Mismatch 
   OOP  != RDBMS

1. Problem of Granularity
  Problem: Number of classes mapping to the number of tables in the database do not match
 
---

## üîπ What is the Problem of Granularity?

In **JDBC / plain SQL**, we often try to map **database tables ‚Üí Java classes**.
But in real-world apps, this mapping is **not 1-to-1**.

### Example:

**Database Table**:

```sql
CREATE TABLE owner (
    id INT PRIMARY KEY,
    first_name VARCHAR(50),
    last_name VARCHAR(50),
    gender CHAR(1),
    city VARCHAR(50),
    state VARCHAR(50)
);
```

**Naive Java Class (matching table)**:

```java
public class Owner {
    private int id;
    private String firstName;
    private String lastName;
    private String gender;
    private String city;
    private String state;
}
```

üëâ This works fine if table and class structure are **exactly same**.

---

But reality is different:

* DB might normalize data into many tables (`owner`, `pet`, `address` ‚Ä¶)
* Java developer might want **richer domain models** with nested objects, collections, enums, inheritance, etc.

### Example Granularity Issue:

**Database Tables** (normalized):

```sql
CREATE TABLE owner (id INT, first_name VARCHAR(50), last_name VARCHAR(50));
CREATE TABLE address (id INT, city VARCHAR(50), state VARCHAR(50));
CREATE TABLE pet (id INT, owner_id INT, name VARCHAR(50), type VARCHAR(20));
```

**Java Domain Model** (more natural for OOP):

```java
public class Owner {
    private int id;
    private String firstName;
    private String lastName;
    private Address address;       // Composition
    private List<Pet> pets;        // Collection
}

public class Address {
    private String city;
    private String state;
}

public class Pet {
    private String name;
    private String type;
}
```

‚ö†Ô∏è Problem:

* 1 `Owner` class spans **3 tables**.
* 1 `Pet` table can map to **many Pet objects**.
* 1 `Address` table might be reused by multiple owners.

This mismatch between **relational tables** and **object-oriented classes** is called the **Granularity Problem**.

---

## üîπ Why Hibernate Helps?

Hibernate (and other ORMs like JPA) solve this problem by **managing the mapping** between **tables and classes** automatically.

### Benefits Hibernate provides:

1. **Automatic Mapping**

   * You annotate classes with `@Entity`, `@OneToMany`, `@ManyToOne`, etc.
   * Hibernate figures out how to join multiple tables and populate your objects.

2. **Rich OOP Domain Models**

   * You can design Java classes the way you want (composition, inheritance, collections) without worrying about how many tables exist in DB.

3. **Transparent Persistence**

   * You just call `session.save(owner);` ‚Üí Hibernate inserts into `owner`, `pet`, and `address` tables as needed.

4. **Less Boilerplate Code**

   * No need for manual `ResultSet` parsing and mapping fields to Java objects.

---

## üîπ Summary

* **Granularity Problem** = mismatch between number of tables in DB and number of classes in Java domain model.
* Plain JDBC struggles because it forces you to write **manual joins, mapping, conversions**.
* **Hibernate solves it** by handling:

  * **1 Class ‚Üî Many Tables**
  * **Many Classes ‚Üî 1 Table**
  * **Collections ‚Üî Join Tables**
  * **Inheritance ‚Üî Table per class / Table per hierarchy**

